#!/usr/bin/env node

// [pathlength](http://neocotic.com/pathlength) 0.1.0  
// Copyright (c) 2013 Alasdair Mercer  
// Freely distributable under the MIT license.  
// For all details and documentation:  
// <http://neocotic.com/pathlength>

'use strict';

// Module dependencies
// -------------------

var pathlength = require('../lib/pathlength')
  , program    = require('commander')
  , util       = require('util');

// Option parsing
// --------------

program
  .version(pathlength.version)
  .usage('[options] [target]')
  .option('-d, --debug',               'output debug messages')
  .option('-f, --filter [expression]', 'filter expression to use')
  .option('-n, --no-headers',          'don\'t output headers for certain formats')
  .option('-o, --output [format]',     'format for output', 'simple')
  .option('-p, --progressive',         'output matches as they are found')
  .option('-r, --recursive',           'check directories recursively')
  .option('-s, --stop',                'don\'t search unfiltered directories')
  .parse(process.argv);

if (program.debug) {
  console.log('args: %j',        program.args);
  console.log('debug: %j',       program.debug);
  console.log('filter: %s',      program.filter);
  console.log('headers: %j',     program.headers);
  console.log('output: %j',      program.output);
  console.log('progressive: %j', program.progressive);
  console.log('recursive: %j',   program.recursive);
  console.log('stop: %j\n',      program.stop);
}

// Table formatting
// ----------------

var columns = [
    {
        cell: function(data) {
          return data.path;
        }
      , header: 'Path'
      , padding: 0
    }
  , {
        cell: function(data) {
          return String(data.length);
        }
      , header: 'Length'
      , padding: 0
    }
  , {
        cell: function(data) {
          return data.directory ? 'Directory' : 'File';
        }
      , header: 'Type'
      , padding: 0
    }
];

// If headers are enabled, the maximum width for each column needs to be calculated for padding
// later. This is not done in progressive mode as we're not able to predetermine the maximum column
// widths for subsequent rows.
if (program.headers && !program.progressive) {
  columns.forEach(function (col) {
    col.padding = col.header.length;
  });
}

// Pad `str` to `width`.
function pad(str, width) {
  return str.concat(new Array(Math.max(0, width - str.length) + 1).join(' '));
}

var format, formatAll;

// Format the given `data` based on the `event` fired.  
// If `event` is **end** and progressive mode is enabled, no other events will actually be
// triggered as `formatAll` will be used to simulate each one.
format = function(event, data) {
  switch (program.output.toLowerCase()) {
    // Comma-separated values
    case 'c':
    case 'csv':
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return util.format('"%s","%d","%s"', data.path, data.length,
            data.directory ? 'Directory' : 'File');
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
      break;
    // JSON
    case 'j':
    case 'json':
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return JSON.stringify({
              path:   data.path
            , length: data.length
            , type:   data.directory ? 'Directory' : 'File'
          }, null, 2);
        case 'end':
          if (program.progressive) return '';
          return JSON.stringify(data.map(function (row) {
            return {
                path:   row.path
              , length: row.length
              , type:   row.directory ? 'Directory' : 'File'
            };
          }), null, 2);
        default:
          return '';
      }
      break;
    // Table
    case 't':
    case 'table':
      var buf = '';
      switch (event) {
        case 'afterStart':
          if (!program.headers) return '';
          columns.forEach(function (col) {
            buf = buf.concat(col.padding ? pad(col.header, col.padding + 1) :
              col.header.concat('\t'));
          });
          return buf.concat('\n');
        case 'betweenData':
          return '\n';
        case 'data':
          columns.forEach(function (col) {
            buf = buf.concat(col.padding ? pad(col.cell(data), col.padding + 1) :
              col.cell(data).concat('\t'));
          });
          return buf;
        case 'end':
          if (program.progressive) return '';
          // Calculate maximum width for each column in this row for padding.
          data.forEach(function (row) {
            columns.forEach(function (col) {
              var len = col.cell(row).length;
              if (len > col.padding) {
                col.padding = len;
              }
            });
          });
          return formatAll(data);
        default:
          return '';
      }
      break;
    // XML
    case 'x':
    case 'xml':
      switch (event) {
        case 'start':
          return '<?xml version="1.0" encoding="UTF-8" ?>\n<results>';
        case 'beforeData':
          return '\n';
        case 'data':
          return util.format('  <result path=%j length="%d" type="%s" />', data.path, data.length,
            data.directory ? 'Directory' : 'File');
        case 'beforeEnd':
          return (data.length ? '\n' : '').concat('</results>');
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
      break;
    // Simple (default)
    case 's':
    case 'simple':
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return util.format('%s:%d', data.path, data.length);
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
      break;
    default:
      pathlength.emit('error', util.format('Invalid format: %s', program.output));
  }
};

// Format all data within `dataSet` by programmatically calling `format`, simulating all necessary
// events.
formatAll = function(dataSet) {
  var buf = format('start').concat(dataSet.length ? format('afterStart') : '');
  dataSet.forEach(function (data, i) {
    buf = buf.concat(i ? format('betweenData') : '')
      .concat(format('beforeData', data))
      .concat(format('data',       data))
      .concat(format('afterData',  data));
  });
  return buf.concat(format('beforeEnd', dataSet));
};

// Event management
// ----------------

[
    'start'
  , 'afterStart'
  , 'betweenData'
  , 'beforeData'
  , 'data'
  , 'afterData'
  , 'beforeEnd'
  , 'end'
].slice(program.progressive ? 0 : -1).forEach(function (event) {
  pathlength.on(event, function (data) {
    var output = format(event, data);
    if (event === 'end') {
      output += '\n';
    }
    process.stdout.write(output);
  });
});

pathlength.on('error', function (err) {
  process.stderr.write(err);
});

// Processing
// ----------

pathlength.debug = !!program.debug;
pathlength.find({
    filter:    program.filter
  , recursive: !!program.recursive
  , stop:      !!program.stop
  , target:    program.args[0]
});
