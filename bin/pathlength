#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander')
  , util = require('util')
  , pathlength = require('../');

/**
 * Option parsing.
 */

program
  .version(pathlength.version)
  .usage('[options] [target]')
  .option('-d --debug', 'output debug messages')
  .option('-f --filter [expression]', 'filter expression to use')
  .option('-h --headers', 'output headers for certain formats')
  .option('-o --output [format]', 'format for output', 'simple')
  .option('-p --progressive', 'output matches as they are found')
  .option('-r --recursive', 'check directories recursively')
  .option('-s --stop', 'don\'t search unfiltered directories')
  .parse(process.argv);

if (program.debug) {
  console.log('args: %j', program.args);
  console.log('debug: %j', program.debug);
  console.log('filter: %j', program.filter);
  console.log('headers: %j', program.headers);
  console.log('output: %j', program.output);
  console.log('progressive: %j', program.progressive);
  console.log('recursive: %j', program.recursive);
  console.log('stop: %j', program.stop);
  console.log('');
}

/** Result formatting. */

var columns = [
    {   cell: function(data) {
          return data.path;
        }
      , header: 'Path'
      , padding: 0
    }
  , {   cell: function(data) {
          return String(data.length);
        }
      , header: 'Length'
      , padding: 0
    }
  , {   cell: function(data) {
          return data.directory ? 'Directory' : 'File';
        }
      , header: 'Type'
      , padding: 0
    }
];

// Calculate maximum column lengths (based on headers only) for padding.
if (program.headers && !program.progressive) {
  columns.forEach(function(col) {
    col.padding = col.header.length;
  });
}

/**
 * 
 */

function format(event, data) {
  switch (program.output.toLowerCase()) {
    case 'c':
    case 'csv':
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return util.format('"%s","%d","%s"'
              , data.path
              , data.length
              , data.directory ? 'Directory' : 'File');
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
      break;
    case 'j':
    case 'json':
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return JSON.stringify({
              path: data.path
            , length: data.length
            , type: data.directory ? 'Directory' : 'File'
          }, null, 2);
        case 'end':
          if (program.progressive) return '';
          return JSON.stringify(data.map(function(result) {
            return {
                path: data.path
              , length: data.length
              , type: data.directory ? 'Directory' : 'File'
            };
          }), null, 2);
        default:
          return '';
      }
      break;
    case 't':
    case 'table':
      var buf = '';
      switch (event) {
        case 'afterStart':
          if (!program.headers) return '';
          columns.forEach(function(col) {
            buf = buf.concat(col.padding
              ? pad(col.header, col.padding + 1)
              : col.header.concat('\t'));
          });
          return buf.concat('\n');
        case 'betweenData':
          return '\n';
        case 'data':
          columns.forEach(function(col) {
            buf = buf.concat(col.padding
              ? pad(col.cell(data), col.padding + 1)
              : col.cell(data).concat('\t'));
          });
          return buf;
        case 'end':
          if (program.progressive) return '';
          // Calculate maximum column lengths (based on cells only) for padding
          data.forEach(function(row) {
            columns.forEach(function(col) {
              var len = col.cell(row).length;
              if (len > col.padding) col.padding = len;
            });
          });
          return formatAll(data);
        default:
          return '';
      }
      break;
    case 'x':
    case 'xml':
      switch (event) {
        case 'afterStart':
          return '<?xml version="1.0" encoding="UTF-8" ?>'
            .concat('\n')
            .concat('<results>')
            .concat('\n');
        case 'betweenData':
          return '\n';
        case 'data':
          return util.format('  <result path=%j length="%d" type="%s" />'
              , data.path
              , data.length
              , data.directory ? 'Directory' : 'File');
        case 'beforeEnd':
          return '\n'
            .concat('</results>');
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
      break;
    case 's':
    case 'simple':
    default:
      switch (event) {
        case 'betweenData':
          return '\n';
        case 'data':
          return util.format('%s:%d', data.path, data.length);
        case 'end':
          return program.progressive ? '' : formatAll(data);
        default:
          return '';
      }
  }
}

function formatAll(dataSet) {
  var buf = format('start')
    .concat(dataSet.length ? format('afterStart') : '');
  dataSet.forEach(function(data, i) {
    buf = buf
      .concat(i ? format('betweenData') : '')
      .concat(format('beforeData', data))
      .concat(format('data', data))
      .concat(format('afterData', data));
  });
  return buf.concat(format('beforeEnd', dataSet));
}

/**
 * Pad `str` to `width`.
 * 
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  return str.concat(Array(Math.max(0, width - str.length) + 1).join(' '));
}

/** Event management. */

function eventHandler(e, data) {
  process.stdout.write(format(e.type, data));
}

(program.progressive
  ? 'start afterStart betweenData beforeData data afterData beforeEnd'
  : 'end')
    .split(' ')
    .forEach(function(event) {
      pathlength.on(event, eventHandler);
    });

/** Processing. */

pathlength.debug = !!program.debug;
pathlength.find({
    filter: program.filter
  , recursive: !!program.recursive
  , stop: !!program.stop
  , target: program.args[0]
});